<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>cells</key>
	<array>
		<dict>
			<key>column</key>
			<integer>1</integer>
			<key>row</key>
			<integer>1</integer>
			<key>stringValue</key>
			<string>Dependencia read after write (RaW)! Como i cresce, o valor de a[i+1] e alterado na proxima iteracao anterior. Codigo nao vectorizavel.
Dependencia write after read (WaR). Como i cresce, o valor de a[i+1] so sera alterado na proxima iteracao. Codigo vectorizavel.
Distancia da dependencia : diferenca entre o indice de escrita e o indice de leitura 
Se d &lt;= 0 nao ha dependências RaW : ciclo pode ser vectorizado
Se d &gt; 0 nao ha dependências WaR : ciclo pode ser vectorizado 
Se i—— entao -d, se i++ entao d

Processamento Vectorial: Linhas de Orientacao 
Usar ciclos “for” contaveis: pontos unicos de entrada e saida; 
Evitar estruturas condicionais; mascaras sao vectorizaveis, mas resultam na realizacao de trabalho inutil;  Evitar dependencias, especialmente do tipo “read-after-write”  Evitar a utilizacao de apontadores e prevenir aliasing  Usar acessos a memoria eficientes: 
–  Ciclo mais aninhado com stride 1 (dados consecutivos) 
–  Minimizar acessos indirectos 
–  Alinhar os dados a multiplos de 16 (Intel SSE) </string>
		</dict>
	</array>
	<key>device name</key>
	<string>untitled</string>
	<key>device type</key>
	<string>TI-84 Plus</string>
	<key>isProtected</key>
	<false/>
	<key>object type</key>
	<string>Program</string>
</dict>
</plist>
